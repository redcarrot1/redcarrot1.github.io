---
title: KUPC 해설2
date: 2023-11-13 10:00:00 +09:00
categories: [알고리즘]
tags:
  [
    Algorithm, KUPC
  ]
img_path: /assets/img/etc/kupc/
math: true
---

[대회 링크](https://www.acmicpc.net/contest/view/1173), [공식 해설](https://solved.ac/arena/10/editorial)


A번부터 I번까지의 문제 해설은 [이전 게시물](https://redcarrot1.github.io/posts/KUPC_%ED%9B%84%EA%B8%B0/)을 참고해주세요.<br>
K번 문제부터 난이도가 어렵습니다. 천천히 살펴보도록 하죠


## K. MEXchange
주어진 수열 $B$는 반드시 오름차순이어야 합니다. 그리고 마지막 원소는 반드시 $n+1$이어야합니다. 만일 그렇지 않다면 `No`를 출력하시면 됩니다. 이 규칙은 금방 찾았으리라 생각됩니다.<br>
수열 $B$에서 수가 바뀌는 순간을 생각해볼께요. 예를 들어, $1, 2, 2, 2, 6$이라 하겠습니다. 2에서 6으로 바뀌는 이유가 뭘까요? 바뀌는 순간에 순열 $A$에서 해당 수가 등장했기 때문입니다. 따라서 순열 $A$는 (X, X, X, X, 2)와 같은 모양이어야만 합니다. 1에서 2로 바뀌는 순간도 마찬가지입니다. 결론적으로 이 규칙을 통해 우리는 순열 $A$가 (X, 1, X, X, 2)라는 것을 알 수 있습니다.<br>
이제 나머지 X 부분도 채워보죠. 이 문제는 `스페셜 저지` 입니다. 따라서 답이 여러개 나올 수 있어요. (답이 가능하다면) 무조건 가능한 경우는, X 부분에 남은 수들을 **오름차순**으로 그리디하게 수를 채우면 됩니다. 왜그럴까요?<br>
주어진 수열 $B$는 오름차순이어야만 합니다. 또한 반드시 $i$번째 원소인 $B_i$는 $A_j < B_i, \forall j>i$이어야 합니다. 따라서 답이 존재한다면 위와 같은 전략으로 만든 $A$가 반드시 존재합니다.<br>
$A$를 찾은 뒤 다시 한번 for문을 돌리면서 주어진 $B$를 만족하는지 체크해줍니다. 만족하지 않다면 `No`를, 만족한다면 `Yes`와 $A$를 출력하시면 됩니다. $O(N)$에 풀 수 있습니다. 당장 이해가 안되더라도, 펜으로 따라가시면서 천천히 생각해보시면 금방 이해되실 겁니다.

![](4.png){: width="400" height="" }

## L. 등불 날리기
사이즈가 S인 구간에서 $i<j, A_i < A_j$ 인 pair의 개수를 구하는 문제였습니다. `inversion count`라는 알고리즘이 존재합니다. 궁금하신 분은 직접 찾아보시면 좋을것 같습니다.<br>
다른 방법으로는 슬라이딩 윈도우 + 세그트리 + 좌표압축으로 풀 수 있습니다. 아이디어가 아주 기발한데, 아마 전에 접해보지 않았다면 상당히 어려울 것 같습니다. 저도 이전에 어느 문제에서 이 아이디어를 본 적이 있는데, 완전히 잊고 있다가 무척 힘들게 풀었네요.<br>
먼저 쉬운 이해를 위해 가정을 하겠습니다. 사이즈가 S인 어떤 구간은 주어진 배열 $A$의 적절한 중간에 위치해있고, 찾고자 하는 pair의 개수를 알고있다고 하겠습니다.

![](5.png){: width="400" height="" }

구간을 오른쪽으로 한칸 이동하고 싶습니다. 즉, 9를 내보내고 8을 포함시키고 싶습니다. 그럼 pair의 개수 변화는 어떨까요? 9로 인해 추가된 pair개수는 빼야합니다. 그리고 새로 들어온 8로 인해 추가된 pair 개수는 더해야 합니다. 이때 사용하는 아이디어가 세그트리입니다.<br>
먼저 좌표압축을 하겠습니다. 모든 원소를 오름차순 정렬 후 1부터 숫자를 쭉 부여하겠습니다. 이때 같은 수를 가지면 압축도 같은 수로 해야합니다. 우리는 수들의 대소관계만 유지하면 되기 때문에 본질적인 문제는 바뀌지 않습니다. 좌표 압축 후에 최소는 1, 최대는 M이라 하겠습니다.

![](6.png){: width="400" height="" }

세그트리를 사용하면 구간 6부터 M까지의 원소 합을 구할 수 있는데요, 이를 활용해서 원소 개수를 카운팅해주면 됩니다. 

![](7.png){: width="400" height="" }

우리는 5를 내보내고 싶습니다. 따라서 6이상, M이하의 원소 개수를 pair에서 빼야해요. 즉, 세그트리에서 `find(6, M)`을 pair에서 빼주면 됩니다. 그리고 세그트리를 업데이트해줍니다. (인덱스 5번원소를 -1 시키기 : `update(5, -1)`) <br>
그리고 우리는 4를 추가하고 싶습니다. 세그트리에서 `find(1, 3)`을 pair에 더한 뒤 세그트리를 업데이트 해줍니다. (`update(4, +1)`)

위 과정을 슬라이딩 윈도우를 이용해 오른쪽으로 쭉 이동시키며 반복하면 됩니다. 세그먼트 트리 연산이 $O(\log N)$이므로 총 시간복잡도는 $O(N\log N)$ 입니다.

## M. 우정은 BFS처럼, 사랑은 DFS처럼


## N. 양송 정렬

