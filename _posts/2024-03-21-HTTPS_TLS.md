---
title: HTTPS와 TLS
date: 2024-03-21 10:00:00 +09:00
categories: [암호학]
tags:
  [
    HTTPS, TLS
  ]
img_path: /assets/img/cryptography/
---

## Intro
HTTPS(HyperText Transfer Protocol Secure)은 HTTP 프로토콜에 보안을 강화한 버전입니다. 이번 게시물에서는 보안이 어떤 식으로 강화가 되는지 알아보고자 합니다.<br>
기본적으로 암호학의 지식이 필요합니다. 제가 전에 게시했던 [포스팅](https://redcarrot1.github.io/categories/암호학/)을 적극적으로 활용하겠습니다.

먼저 기본적인 암호 시스템을 알아봅시다.

## 대칭키와 비대칭키
대칭키(Symmetric key)는 암호화와 복호화에 같은 암호 키를 쓰는 알고리즘을 말합니다. Secret Key System에서 사용됩니다.<br>
주로 전통적인 암호 시스템이 대칭키를 기반으로 만들어졌습니다. 단순 문자 치환(Substitution)부터 시작해서 현대의 DES, AES도 대칭키 암호에 해당합니다.<br>
암호화와 복호화에 같은 암호 키를 사용하기 때문에 송신자, 수신자는 암호 키를 공유하고 있어야 합니다. 암호키를 어떻게 안전하게 서로 공유할까요? 암호키를 공유하기 위한 암호키를 또 사용하나요? 그럼 수레바퀴처럼 암호키가 만들어집니다. 해답 중 하나는 비대칭키입니다.<br>
장점도 있습니다. 대칭키 암호는 내부 구조가 간단한 치환과 전치의 조합으로 되어 있어 연산 속도가 빠르다는 장점이 있습니다.

비대칭키(Asymmetric Key) 암호는 암호화, 복호화에 서로 다른 키를 사용하는 알고리즘입니다. Public Key System에서 사용됩니다.<br>
송신자는 수신자의 **공개키**를 이용하여 암호화하며, 수신자는 자신의 **개인키(또는 비밀키)**로 복호화할 수 있습니다.<br>
공개키 암호는 수학적인 난제(계산 속도)나 복잡한 수학 연산을 기반으로 설계되어 있기 때문에 대칭키 암호보다 효율성이 떨어집니다.<br>
대표적으로 [RSA](https://redcarrot1.github.io/posts/RSA_1/), [ElGamal](https://redcarrot1.github.io/posts/Discrete_Log_Problem/#elgamal)이 있습니다.

## 디지털 성명
디지털 성명(Digital Signature)에 대한 자세한 이야기는 전에 포스팅했던 링크로 대체하겠습니다. <br>
[Signature1](http://localhost:4000/posts/Signatures_1/), [Signature2](http://localhost:4000/posts/Signatures_2/) <br>

![](10.png){: width="700" height="" }

핵심만 요약하자면, 디지털 성명에서도 공개키와 비밀키가 사용됩니다.<br>
RSA에서는 공개키로 암호화, 비밀키로 복호화 했었습니다. Signature은 비밀키로 암호화, 공개키로 복호화 합니다.<br>
누구나 공개키로 메시지를 복호화할 수 있습니다. 메시지 m과 복호화한 메시지 m'을 서로 비교해서, 메시지 송신자를 인증하게 됩니다.<br>


주의하실 점은 디지털 성명은 암호화 시스템이 아닙니다. 송신자(또는 메시지 작성자)가 누구인지를 인증해주는 시스템입니다. 따라서 메시지 m과 signature을 같이 전송합니다.

앞서 이야기 했던 것처럼 공개키 시스템은 비용이 큽니다. 메시지 m이 길수록 더 비용이 많이 듭니다.<br>
비용을 줄이고자 메시지 m에 hash function을 적용하여 고정된 길이의 메시지(digest H(m))을 만들어 사용합니다. 대표적으로 해싱 알고리즘으로 SHA(Secure Hash 
Algorithm)을 사용합니다.<br>

![](11.png){: width="700" height="" }

해쉬 함수의 특정으로는 Many-to-one 입니다. 서로 다른 메시지 a, b가 같은 해쉬 결과를 만들 수 있습니다. 하지만 Birthday paradox의 예시처럼, 어떤 메시지 m과 동일한 해싱 결과를 같은 다른 메시지 m'를 찾는건 매우 힘듭니다. 이 내용은 [전의 포스팅](https://redcarrot1.github.io/posts/Signatures_2/#cryptographic-hashing)을 참고 바랍니다.

![](12.png){: width="700" height="" }
_[최종판](https://redcarrot1.github.io/posts/Signatures_2/#typical-usage-%EC%B5%9C%EC%A2%85%ED%8C%90)_
보통 위의 이미지와 같이 대칭키, 비대칭키, 해쉬 알고리즘, 디지털 성명을 모두 혼합해서 사용합니다.


## CA(Certificate Authority)
디지털 성명을 무조건 믿을 수 있을까요? Trudy라는 해커가 자신이 Bob인 것처럼 위장했다고 합시다.
Trudy은 자신의 Private Key로 성명 후 메시지를 전송합니다. 수신자측에서는 성명을 풀기 위해 public key를 요구할겁니다. Trudy는 자신의 public key를 보냅니다.<br>
위 스토리의 문제점은 뭘까요? public key가 인증되지 않는다는 점입니다. 그래서 등장한게 Public Key Certification Authority(CA)입니다.

CA는 public key가 누구꺼인지를 보장해줍니다. 먼저 Entity(사람, website, router..)는 CA에 자신의 public key를 등록시킵니다.<br>
그러면 CA는 entity의 정보를 CA's private key로 암호화하여 인증서를 발급해줍니다.<br>

![](13.png){: width="700" height="" }

CA의 public key는 잘 알려져 있습니다. 웹브라우저에는 유명한 CA 목록과 공개키를 가지고 있습니다.<br>
이제 앞으로는 public key를 직접 전송하지 말고, CA가 발급한 인증서를 전송하면 됩니다. 그러면 수신자는 해당 인증서를 CA's public key로 풀어 송신자의 public key를 얻으면 됩니다.

## TLS(Transport-Layer Security)
TLS는 안전한 인터넷 통신을 위한 암호화 및 인증 프로토콜입니다. 데이터를 암호화하고, 메시지가 변형되지 않았음을 보장하며, public key 암호화로 Authentication을 제공합니다. 이번 게시물에서는 데이터 무결성을 보장하는 MAC은 제외하고, 암호화에 초점을 맞추겠습니다.

TLS 암호화를 사용하기 위해서는 TLS 핸드셰이크를 선수행 해야합니다. 그 과정 중에 서로를 검증하며, 사용할 암호화 알고리즘을 구성하고 세션 키를 합의합니다.
아래 내용은 [Cloudflare 게시물](https://www.cloudflare.com/ko-kr/learning/ssl/what-happens-in-a-tls-handshake/)을 참고했습니다.

![](14.png){: width="700" height="" }
_https://www.cloudflare.com/ko-kr/learning/ssl/what-happens-in-a-tls-handshake/_

1. '클라이언트 헬로' 메시지
  - 클라이언트가 서버로 "헬로" 메시지를 전송하면서 핸드셰이크를 개시합니다.
  - 이 메시지에는 클라이언트가 지원하는 TLS 버전, 지원되는 암호 제품군, 그리고 "클라이언트 무작위"라고 하는 무작위 바이트 문자열이 포함됩니다.
2. '서버 헬로' 메시지
  - 클라이언트 헬로 메시지에 대한 응답으로 서버가 서버의 SSL 인증서, 서버에서 선택한 암호 제품군, 그리고 서버에서 생성한 또 다른 무작위 바이트 문자열인 "서버 무작위"를 포함하는 메시지를 전송합니다.
3. 인증
  - 클라이언트가 서버의 SSL 인증서를 인증서 발행 기관을 통해 검증합니다. 이를 통해 서버가 인증서에 명시된 서버인지, 그리고 클라이언트가 상호작용 중인 서버가 실제 해당 도메인의 소유자인지를 확인합니다.
4. 예비 마스터 암호
  - 클라이언트가 "예비 마스터 암호"라고 하는 무작위 바이트 문자열을 하나 더 전송합니다. 예비 마스터 암호는 공개 키로 암호화되어 있으며, 서버가 개인 키로만 해독할 수 있습니다. (클라이언트는 서버의 SSL 인증서를 통해 공개 키를 받습니다.)
5. 개인 키 사용
  - 서버가 예비 마스터 암호를 해독합니다.
6. 세션 키 생성
  - 클라이언트와 서버가 모두 클라이언트 무작위, 서버 무작위, 예비 마스터 암호를 이용해 세션 키를 생성합니다. 모두 같은 결과가 나와야 합니다.
7. 클라이언트 준비 완료
  - 클라이언트가 세션 키로 암호화된 "완료" 메시지를 전송합니다.
8. 서버 준비 완료
  - 서버가 세션 키로 암호화된 "완료" 메시지를 전송합니다.
9. 안전한 대칭 암호화 성공
  - 핸드셰이크가 완료되고, 세션 키를 이용해 통신이 계속 진행됩니다.

![](15.png){: width="700" height="" }

세션 키는 대칭키 시스템입니다. 따라서 암호화, 복호화 속도가 상대적으로 효율적입니다.<br>
대칭키 교환을 위해 비대칭키가 사용됩니다. 비대칭 키의 public key를 안전하게 전송하기 위해 CA의 인증서를 사용하게 됩니다.

## Outro
현대의 암호 시스템은 한 종류로만 이루어지는 경우는 거의 없고, 여러 형태의 알고리즘이 종합적으로 사용됩니다.
암호 자체가 수학과 밀접한 관계가 있기도 하고, 깊게 내려가면 끝없이 연결되는 학문인지라..<br>
그래도 저번 학기 때 수강했던 암호학 강의가 많은 도움이 됐습니다. 공부할 내용이 정말 많긴 했지만 되돌아보면 다 교수님의 사랑이었다(고 믿고싶다.)<br>
